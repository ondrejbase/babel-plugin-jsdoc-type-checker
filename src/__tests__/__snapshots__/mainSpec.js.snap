// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`main should not generate anything because the checker tag is not present 1`] = `
"/**
 * Class Foo.
 */
class Foo {
  /**
   * Returns the sum of x, y (optional).
   *
   * @param {number} x The first number.
   * @param {number} [y=0] The second number.
   * @return {number} The sum of x and y.
   */
  sum(x, y = 0) {
    return x + y;
  }

}"
`;

exports[`main should not generate anything because the environment is production 1`] = `
"/**
 * Class Foo.
 */
class Foo {
  /**
   * Returns the sum of x, y (optional).
   *
   * @type-checked
   * @param {number} x The first number.
   * @param {number} [y=0] The second number.
   * @return {number} The sum of x and y.
   */
  sum(x, y = 0) {
    return x + y;
  }

}"
`;

exports[`main should prepend a type checking to Foo#and() 1`] = `
"/**
 * Class Foo.
 */
class Foo {
  /**
   * Computes a logical AND of x and y (optional).
   *
   * @type-checked
   * @param {boolean} x The first boolean value.
   * @param {boolean=} y The second boolean value.
   * @return {boolean} The logical and of x and y.
   */
  and(x, y) {
    if (typeof x !== 'boolean') {
      throw new TypeError('Argument x must be a boolean.');
    }

    if (y !== null && y !== undefined && typeof y !== 'boolean') {
      throw new TypeError('Argument y (optional) must be a boolean.');
    }

    return x && (y !== null && y !== undefined ? y : true);
  }

}"
`;

exports[`main should prepend a type checking to Foo#concat() 1`] = `
"/**
 * Class Foo.
 */
class Foo {
  /**
   * Concats strings x and y (optional).
   *
   * @type-checked
   * @param {string} x The first string.
   * @param {string} [y=''] The second string.
   * @return {string} The concatenation of x and y.
   */
  concat(x, y = '') {
    if (typeof x !== 'string') {
      throw new TypeError('Argument x must be a string.');
    }

    if (y !== null && y !== undefined && typeof y !== 'string') {
      throw new TypeError('Argument y (optional) must be a string.');
    }

    return x + y;
  }

}"
`;

exports[`main should prepend a type checking to Foo#joinArray() and Foo#joinArray2() 1`] = `
"/**
 * Class Foo.
 */
class Foo {
  /**
   * Joins the elements of an array into a string, and returns the
   * string.
   *
   * @type-checked
   * @param {string[]} arr An array of strings.
   * @return {string} [separator=','] The separator to be used.
   * @return {string} A String, representing the array values,
   *         separated by the specified separator.
   */
  joinArray(arr, separator = ',') {
    if (Object.prototype.toString.call(arr) !== '[object Array]') {
      throw new TypeError('Argument arr must be an array.');
    }

    if (Object.prototype.toString.call(arr) === '[object Array]' && arr.length > 0 && typeof arr[0] !== 'string') {
      throw new TypeError('Argument arr[0] must be a string.');
    }

    return arr.join(separator);
  }
  /**
   * Joins the elements of an array into a string, and returns the
   * string.
   *
   * @type-checked
   * @param {Array<string>=} arr An array of strings.
   * @return {string} [separator=','] The separator to be used.
   * @return {string} A String, representing the array values,
   *         separated by the specified separator.
   */


  joinArray2(arr, separator = ',') {
    if (arr !== null && arr !== undefined && Object.prototype.toString.call(arr) !== '[object Array]') {
      throw new TypeError('Argument arr (optional) must be an array.');
    }

    if (Object.prototype.toString.call(arr) === '[object Array]' && arr.length > 0 && typeof arr[0] !== 'string') {
      throw new TypeError('Argument arr[0] must be a string.');
    }

    return (arr || []).join(separator);
  }

}"
`;

exports[`main should prepend a type checking to Foo#negate() and Foo#negate2() 1`] = `
"/**
 * Class Foo.
 */
class Foo {
  /**
   * Negates the given value.
   *
   * @type-checked
   * @param {(boolean|number|string)} value A value.
   * @return {boolean} The logically negated value.
   */
  negate(value) {
    if (typeof value !== 'boolean' && typeof value !== 'number' && typeof value !== 'string') {
      throw new TypeError('Argument value must be a boolean. OR Argument value must be a number. OR Argument value must be a string.');
    }

    return !value;
  }
  /**
   * Negates the given value.
   *
   * @type-checked
   * @param {!(boolean|number|string)=} value A value.
   * @return {boolean} The logically negated value.
   */


  negate2(value) {
    if ((value !== null && value !== undefined && typeof value !== 'boolean' || value === null) && (value !== null && value !== undefined && typeof value !== 'number' || value === null) && (value !== null && value !== undefined && typeof value !== 'string' || value === null)) {
      throw new TypeError('Argument value (optional) must be a boolean. OR Argument value (optional) must be a number. OR Argument value (optional) must be a string.');
    }

    return !value;
  }

}"
`;

exports[`main should prepend a type checking to Foo#processUserInput() 1`] = `
"/**
 * Class Foo.
 */
class Foo {
  /**
   * Waits for a user input and then calls a callback.
   *
   * @type-checked
   * @param {function} callback A callback which is called with
   *        a user input as an argument.
   */
  processUserInput(callback) {
    if (typeof callback !== 'function') {
      throw new TypeError('Argument callback must be a function.');
    }

    var name = prompt('Please enter your name.');
    callback(name);
  }

}"
`;

exports[`main should prepend a type checking to Foo#push() 1`] = `
"/**
 * Class Foo.
 */
class Foo {
  /**
   * Adds one or more elements to the end of an array and returns
   * the new length of the array.
   *
   * @type-checked
   * @param {Array} arr The array to be extended.
   * @param {...*} [elements] The elements to add to the end of
   *        the array.
   * @return {number} The new length property of the array.
   */
  push(arr, ...elements) {
    if (Object.prototype.toString.call(arr) !== '[object Array]') {
      throw new TypeError('Argument arr must be an array.');
    }

    return arr.push(elements);
  }

}"
`;

exports[`main should prepend a type checking to Foo#size() and Foo#size2() 1`] = `
"/**
 * Class Foo.
 */
class Foo {
  /**
   * Counts properties of the object.
   *
   * @type-checked
   * @param {!object=} obj The object.
   * @return {number} A count of the object's properties.
   */
  size(obj) {
    if (obj !== null && obj !== undefined && Object.prototype.toString.call(obj) !== '[object Object]' || obj === null) {
      throw new TypeError('Argument obj (optional) must be an object.');
    }

    return Object.keys(obj).length;
  }
  /**
   * Counts properties of the object.
   *
   * @type-checked
   * @param {?object=} obj The object or null.
   * @return {number} A count of the object's properties.
   */


  size2(obj) {
    if (obj !== null && obj !== undefined && Object.prototype.toString.call(obj) !== '[object Object]' && obj !== null) {
      throw new TypeError('Argument obj (optional) must be an object.');
    }

    return Object.keys(obj || {}).length;
  }

}"
`;

exports[`main should prepend a type checking to Foo#sum() 1`] = `
"/**
 * Class Foo.
 */
class Foo {
  /**
   * Returns the sum of x, y (optional).
   *
   * @type-checked
   * @param {number} x The first number.
   * @param {number} [y=0] The second number.
   * @return {number} The sum of x and y.
   */
  sum(x, y = 0) {
    if (typeof x !== 'number') {
      throw new TypeError('Argument x must be a number.');
    }

    if (y !== null && y !== undefined && typeof y !== 'number') {
      throw new TypeError('Argument y (optional) must be a number.');
    }

    return x + y;
  }

}"
`;

exports[`main should prepend a type checking to Foo#sum() because the checker tag is present on the class level 1`] = `
"/**
 * Class Foo.
 *
 * @type-checked
 */
class Foo {
  /**
   * Returns the sum of x, y (optional).
   *
   * @param {number} x The first number.
   * @param {number} [y=0] The second number.
   * @return {number} The sum of x and y.
   */
  sum(x, y = 0) {
    if (typeof x !== 'number') {
      throw new TypeError('Argument x must be a number.');
    }

    if (y !== null && y !== undefined && typeof y !== 'number') {
      throw new TypeError('Argument y (optional) must be a number.');
    }

    return x + y;
  }

}"
`;

exports[`main should prepend a type checking to Foo#sum() because the checker tag is set to 'bar' 1`] = `
"/**
 * Class Foo.
 */
class Foo {
  /**
   * Returns the sum of x, y (optional).
   *
   * @bar
   * @param {number} x The first number.
   * @param {number} [y=0] The second number.
   * @return {number} The sum of x and y.
   */
  sum(x, y = 0) {
    if (typeof x !== 'number') {
      throw new TypeError('Argument x must be a number.');
    }

    if (y !== null && y !== undefined && typeof y !== 'number') {
      throw new TypeError('Argument y (optional) must be a number.');
    }

    return x + y;
  }

}"
`;

exports[`main should prepend a type checking to Foo#sum() using Facebook's invariant 1`] = `
"/**
 * Class Foo.
 */
class Foo {
  /**
   * Returns the sum of x, y (optional).
   *
   * @type-checked
   * @param {number} x The first number.
   * @param {number} [y=0] The second number.
   * @return {number} The sum of x and y.
   */
  sum(x, y = 0) {
    invariant(!(typeof x !== 'number'), 'Argument x must be a number.');
    invariant(!(y !== null && y !== undefined && typeof y !== 'number'), 'Argument y (optional) must be a number.');
    return x + y;
  }

}"
`;

exports[`main should prepend a type checking to Foo#sumArray() and Foo#sumArray2() 1`] = `
"/**
 * Class Foo.
 */
class Foo {
  /**
   * Returns a sum of all numbers stored in the array.
   *
   * @type-checked
   * @param {Array.<number>} arr An array of numbers.
   * @return {number} The sum of all numbers.
   */
  sumArray(arr) {
    if (Object.prototype.toString.call(arr) !== '[object Array]') {
      throw new TypeError('Argument arr must be an array.');
    }

    if (Object.prototype.toString.call(arr) === '[object Array]' && arr.length > 0 && typeof arr[0] !== 'number') {
      throw new TypeError('Argument arr[0] must be a number.');
    }

    return arr.reduce((total, x) => total + x, 0);
  }
  /**
   * Returns a sum of all numbers stored in inner arrays.
   *
   * @type-checked
   * @param {Array.<Array.<number>>} [arr] An array of arrays of
   *        numbers.
   * @return {number} The sum of all numbers.
   */


  sumArray2(arr) {
    if (arr !== null && arr !== undefined && Object.prototype.toString.call(arr) !== '[object Array]') {
      throw new TypeError('Argument arr (optional) must be an array.');
    }

    if (Object.prototype.toString.call(arr) === '[object Array]' && arr.length > 0 && Object.prototype.toString.call(arr[0]) !== '[object Array]') {
      throw new TypeError('Argument arr[0] must be an array.');
    }

    if (Object.prototype.toString.call(arr) === '[object Array]' && arr.length > 0 && Object.prototype.toString.call(arr[0]) === '[object Array]' && arr[0].length > 0 && typeof arr[0][0] !== 'number') {
      throw new TypeError('Argument arr[0][0] must be a number.');
    }

    return (arr || []).reduce((total, innerArr) => total + innerArr.reduce((total, x) => total + x, 0), 0);
  }

}"
`;

exports[`main should prepend a type checking to Foo#sumObj() and Foo#sumObj2() 1`] = `
"/**
 * Class Foo.
 */
class Foo {
  /**
   * Returns a sum of all numbers stored in the object.
   *
   * @type-checked
   * @param {Object.<string, number>} obj An object with numbers
   *        as property values.
   * @return {number} The sum of all numbers.
   */
  sumObj(obj) {
    if (Object.prototype.toString.call(obj) !== '[object Object]') {
      throw new TypeError('Argument obj must be an object.');
    }

    if (Object.prototype.toString.call(obj) === '[object Object]' && Object.keys && Object.keys(obj)[0] && typeof Object.keys(obj)[0] !== 'string') {
      throw new TypeError('Argument Object.keys(obj)[0] must be a string.');
    }

    if (Object.prototype.toString.call(obj) === '[object Object]' && Object.keys && Object.keys(obj)[0] && obj[Object.keys(obj)[0]] && typeof obj[Object.keys(obj)[0]] !== 'number') {
      throw new TypeError('Argument obj[Object.keys(obj)[0]] must be a number.');
    }

    return Object.keys(obj).reduce((total, key) => total + obj[key], 0);
  }
  /**
   * Returns a sum of all numbers stored in the object.
   *
   * @type-checked
   * @param {Object<string, number>=} obj An object with numbers
   *        as property values.
   * @return {number} The sum of all numbers.
   */


  sumObj2(obj) {
    if (obj !== null && obj !== undefined && Object.prototype.toString.call(obj) !== '[object Object]') {
      throw new TypeError('Argument obj (optional) must be an object.');
    }

    if (Object.prototype.toString.call(obj) === '[object Object]' && Object.keys && Object.keys(obj)[0] && typeof Object.keys(obj)[0] !== 'string') {
      throw new TypeError('Argument Object.keys(obj)[0] must be a string.');
    }

    if (Object.prototype.toString.call(obj) === '[object Object]' && Object.keys && Object.keys(obj)[0] && obj[Object.keys(obj)[0]] && typeof obj[Object.keys(obj)[0]] !== 'number') {
      throw new TypeError('Argument obj[Object.keys(obj)[0]] must be a number.');
    }

    return Object.keys(obj).reduce((total, key) => total + obj[key], 0);
  }

}"
`;

exports[`main should prepend a type checking to Foo#toCAB() and Foo#toCAB2() 1`] = `
"/**
 * Class Foo.
 */
class Foo {
  /**
   * Returns a string representation of the object with c value
   * first, a value second and b value third.
   *
   * @type-checked
   * @param {{a: number, b: string, c}} obj An object with a, b
   *        and c properties.
   * @return {string} A string representation of the object in
   *         format 'cab'.
   */
  toCAB(obj) {
    if (Object.prototype.toString.call(obj) !== '[object Object]') {
      throw new TypeError('Argument obj must be an object.');
    }

    if (Object.prototype.toString.call(obj) === '[object Object]' && 'a' in obj && typeof obj['a'] !== 'number') {
      throw new TypeError('Argument obj[\\\\'a\\\\'] must be a number.');
    }

    if (Object.prototype.toString.call(obj) === '[object Object]' && 'b' in obj && typeof obj['b'] !== 'string') {
      throw new TypeError('Argument obj[\\\\'b\\\\'] must be a string.');
    }

    const {
      a,
      b,
      c
    } = obj;
    return String(c) + a + b;
  }
  /**
   * Returns a string representation of the object with c value
   * first, a value second and b value third.
   *
   * @type-checked
   * @param {{a: !number, b: ?string, c}=} obj An object with a, b
   *        and c properties.
   * @return {string} A string representation of the object in
   *         format 'cab'.
   */


  toCAB2(obj) {
    if (obj !== null && obj !== undefined && Object.prototype.toString.call(obj) !== '[object Object]') {
      throw new TypeError('Argument obj (optional) must be an object.');
    }

    if (Object.prototype.toString.call(obj) === '[object Object]' && 'a' in obj && (typeof obj['a'] !== 'number' || obj['a'] === null)) {
      throw new TypeError('Argument obj[\\\\'a\\\\'] must be a number.');
    }

    if (Object.prototype.toString.call(obj) === '[object Object]' && 'b' in obj && typeof obj['b'] !== 'string' && obj['b'] !== null) {
      throw new TypeError('Argument obj[\\\\'b\\\\'] must be a string.');
    }

    const {
      a,
      b,
      c
    } = obj || {};
    return String(c) + a + b;
  }

}"
`;

exports[`main should prepend a type checking to Foo#toCBAD() and Foo#toCBAD2 1`] = `
"/**
 * Class Foo.
 */
class Foo {
  /**
   * Returns a string representation of the object with c value
   * first, b value second, a value third and d value fourth.
   *
   * @type-checked
   * @param {Object} obj An object with a, b and c properties.
   * @param {number} obj.a Property a.
   * @param {string} [obj.b] Property b.
   * @param {*} obj.c Property c.
   * @param {string} d Value d.
   * @return {string} A string representation of the object in
   *         format 'cbad'.
   */
  toCBAD(obj, d) {
    if (Object.prototype.toString.call(obj) !== '[object Object]') {
      throw new TypeError('Argument obj must be an object.');
    }

    if (Object.prototype.toString.call(obj) === '[object Object]' && 'a' in obj && typeof obj['a'] !== 'number') {
      throw new TypeError('Argument obj[\\\\'a\\\\'] must be a number.');
    }

    if (Object.prototype.toString.call(obj) === '[object Object]' && 'b' in obj && obj['b'] !== null && obj['b'] !== undefined && typeof obj['b'] !== 'string') {
      throw new TypeError('Argument obj[\\\\'b\\\\'] (optional) must be a string.');
    }

    if (typeof d !== 'string') {
      throw new TypeError('Argument d must be a string.');
    }

    const {
      a,
      b,
      c
    } = obj;
    return String(c) + b + a + d;
  }
  /**
   * Returns a string representation of the object with c value
   * first, b value second, a value third and d value fourth.
   *
   * @type-checked
   * @param {Object=} obj An object with a and inner properties.
   * @param {number=} obj.a Property a.
   * @param {Object=} obj.inner An inner object with b and c
   *        properties.
   * @param {?string} obj.inner.b Property b.
   * @param {*} obj.inner.c Property c.
   * @param {string} d Value d.
   * @return {string} A string representation of the object in
   *         format 'cbad'.
   */


  toCBAD2(obj, d) {
    if (obj !== null && obj !== undefined && Object.prototype.toString.call(obj) !== '[object Object]') {
      throw new TypeError('Argument obj (optional) must be an object.');
    }

    if (Object.prototype.toString.call(obj) === '[object Object]' && 'a' in obj && obj['a'] !== null && obj['a'] !== undefined && typeof obj['a'] !== 'number') {
      throw new TypeError('Argument obj[\\\\'a\\\\'] (optional) must be a number.');
    }

    if (Object.prototype.toString.call(obj) === '[object Object]' && 'inner' in obj && obj['inner'] !== null && obj['inner'] !== undefined && Object.prototype.toString.call(obj['inner']) !== '[object Object]') {
      throw new TypeError('Argument obj[\\\\'inner\\\\'] (optional) must be an object.');
    }

    if (Object.prototype.toString.call(obj) === '[object Object]' && 'inner' in obj && Object.prototype.toString.call(obj['inner']) === '[object Object]' && 'b' in obj['inner'] && typeof obj['inner']['b'] !== 'string' && obj['inner']['b'] !== null) {
      throw new TypeError('Argument obj[\\\\'inner\\\\'][\\\\'b\\\\'] must be a string.');
    }

    if (typeof d !== 'string') {
      throw new TypeError('Argument d must be a string.');
    }

    const {
      a,
      inner
    } = obj || {};
    const {
      b,
      c
    } = inner || {};
    return String(c) + b + a + d;
  }

}"
`;

exports[`main should prepend a type checking to Foo#toString() 1`] = `
"/**
 * Class Foo.
 */
class Foo {
  /**
   * Returns a string representing the object.
   *
   * @type-checked
   * @param {object} obj The object to be represented as
   *        a string.
   * @return {string} A string representing the object.
   */
  toString(obj) {
    if (Object.prototype.toString.call(obj) !== '[object Object]') {
      throw new TypeError('Argument obj must be an object.');
    }

    return obj.toString();
  }

}"
`;
