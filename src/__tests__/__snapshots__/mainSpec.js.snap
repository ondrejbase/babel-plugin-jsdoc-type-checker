// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`main should prepend a type checking to Foo#and() 1`] = `
"
/**
 * Class Foo.
 */
class Foo {
	/**
  * Computes a logical AND of x and y (optional).
  *
  * @type-checked
  * @param {boolean} x The first boolean value.
  * @param {boolean=} y The second boolean value.
  * @return {boolean} The logical and of x and y.
  */
	and(x, y) {
		if (typeof x !== 'boolean') {
			throw new TypeError('Argument x must be a boolean.');
		}if (y !== null && y !== undefined && typeof y !== 'boolean') {
			throw new TypeError('Argument y (optional) must be a boolean.');
		}
		return x && (y !== null && y !== undefined ? y : true);
	}
}"
`;

exports[`main should prepend a type checking to Foo#concat() 1`] = `
"
/**
 * Class Foo.
 */
class Foo {
	/**
  * Concats strings x and y (optional).
  *
  * @type-checked
  * @param {string} x The first string.
  * @param {string} [y=''] The second string.
  * @return {string} The concatenation of x and y.
  */
	concat(x, y = '') {
		if (typeof x !== 'string') {
			throw new TypeError('Argument x must be a string.');
		}if (y !== null && y !== undefined && typeof y !== 'string') {
			throw new TypeError('Argument y (optional) must be a string.');
		}
		return x + y;
	}
}"
`;

exports[`main should prepend a type checking to Foo#joinArray() and Foo#joinArray2() 1`] = `
"
/**
 * Class Foo.
 */
class Foo {
	/**
  * Joins the elements of an array into a string, and returns the
  * string.
  *
  * @type-checked
  * @param {string[]} arr An array of strings.
  * @return {string} [separator=','] The separator to be used.
  * @return {string} A String, representing the array values,
  *         separated by the specified separator.
  */
	joinArray(arr, separator = ',') {
		if (Object.prototype.toString.call(arr) !== '[object Array]') {
			throw new TypeError('Argument arr must be an array.');
		}if (Object.prototype.toString.call(arr) === '[object Array]' && arr.length > 0 && typeof arr[0] !== 'string') {
			throw new TypeError('Argument arr[0] must be a string.');
		}
		return arr.join(separator);
	}

	/**
  * Joins the elements of an array into a string, and returns the
  * string.
  *
  * @type-checked
  * @param {Array<string>} arr An array of strings.
  * @return {string} [separator=','] The separator to be used.
  * @return {string} A String, representing the array values,
  *         separated by the specified separator.
  */
	joinArray2(arr, separator = ',') {
		if (Object.prototype.toString.call(arr) !== '[object Array]') {
			throw new TypeError('Argument arr must be an array.');
		}if (Object.prototype.toString.call(arr) === '[object Array]' && arr.length > 0 && typeof arr[0] !== 'string') {
			throw new TypeError('Argument arr[0] must be a string.');
		}
		return arr.join(separator);
	}
}"
`;

exports[`main should prepend a type checking to Foo#negate() 1`] = `
"
/**
 * Class Foo.
 */
class Foo {
	/**
  * Negates the given value.
  *
  * @type-checked
  * @param {(boolean|number|string)} value A value.
  * @return {boolean} The logically negated value.
  */
	negate(value) {
		if (typeof value !== 'boolean' && typeof value !== 'number' && typeof value !== 'string') {
			throw new TypeError('Argument value must be a boolean. OR Argument value must be a number. OR Argument value must be a string.');
		}
		return !value;
	}
}"
`;

exports[`main should prepend a type checking to Foo#push() 1`] = `
"
/**
 * Class Foo.
 */
class Foo {
	/**
  * Adds one or more elements to the end of an array and returns
  * the new length of the array.
  *
  * @type-checked
  * @param {Array} arr The array to be extended.
  * @param {...*} [elements] The elements to add to the end of
  *        the array.
  * @return {number} The new length property of the array.
  */
	push(arr, ...elements) {
		if (Object.prototype.toString.call(arr) !== '[object Array]') {
			throw new TypeError('Argument arr must be an array.');
		}
		return arr.push(elements);
	}
}"
`;

exports[`main should prepend a type checking to Foo#size() and Foo#size2() 1`] = `
"
/**
 * Class Foo.
 */
class Foo {
	/**
  * Counts properties of the object.
  *
  * @type-checked
  * @param {!object=} obj The object.
  * @return {number} A count of the object's properties.
  */
	size(obj) {
		if (obj !== null && obj !== undefined && Object.prototype.toString.call(obj) !== '[object Object]' || obj === null) {
			throw new TypeError('Argument obj (optional) must be an object.');
		}
		return Object.keys(obj).length;
	}

	/**
  * Counts properties of the object.
  *
  * @type-checked
  * @param {?object=} obj The object or null.
  * @return {number} A count of the object's properties.
  */
	size2(obj) {
		if (obj !== null && obj !== undefined && Object.prototype.toString.call(obj) !== '[object Object]' && obj !== null) {
			throw new TypeError('Argument obj (optional) must be an object.');
		}
		return Object.keys(obj || {}).length;
	}
}"
`;

exports[`main should prepend a type checking to Foo#sum() 1`] = `
"
/**
 * Class Foo.
 */
class Foo {
	/**
  * Returns the sum of x, y (optional).
  *
  * @type-checked
  * @param {number} x The first number.
  * @param {number} [y=0] The second number.
  * @return {number} The sum of x and y.
  */
	sum(x, y = 0) {
		if (typeof x !== 'number') {
			throw new TypeError('Argument x must be a number.');
		}if (y !== null && y !== undefined && typeof y !== 'number') {
			throw new TypeError('Argument y (optional) must be a number.');
		}
		return x + y;
	}
}"
`;

exports[`main should prepend a type checking to Foo#sumArray() and Foo#sumArray2() 1`] = `
"
/**
 * Class Foo.
 */
class Foo {
	/**
  * Returns a sum of all numbers stored in the array.
  *
  * @type-checked
  * @param {Array.<number>} arr An array of numbers.
  * @return {number} The sum of all numbers.
  */
	sumArray(arr) {
		if (Object.prototype.toString.call(arr) !== '[object Array]') {
			throw new TypeError('Argument arr must be an array.');
		}if (Object.prototype.toString.call(arr) === '[object Array]' && arr.length > 0 && typeof arr[0] !== 'number') {
			throw new TypeError('Argument arr[0] must be a number.');
		}
		return arr.reduce((total, x) => total + x, 0);
	}

	/**
  * Returns a sum of all numbers stored in inner arrays.
  *
  * @type-checked
  * @param {Array.<Array.<number>>} [arr] An array of arrays of
  *        numbers.
  * @return {number} The sum of all numbers.
  */
	sumArray2(arr) {
		if (arr !== null && arr !== undefined && Object.prototype.toString.call(arr) !== '[object Array]') {
			throw new TypeError('Argument arr (optional) must be an array.');
		}if (Object.prototype.toString.call(arr) === '[object Array]' && arr.length > 0 && Object.prototype.toString.call(arr[0]) !== '[object Array]') {
			throw new TypeError('Argument arr[0] must be an array.');
		}if (Object.prototype.toString.call(arr) === '[object Array]' && arr.length > 0 && Object.prototype.toString.call(arr[0]) === '[object Array]' && arr[0].length > 0 && typeof arr[0][0] !== 'number') {
			throw new TypeError('Argument arr[0][0] must be a number.');
		}
		return (arr || []).reduce((total, innerArr) => total + innerArr.reduce((total, x) => total + x, 0), 0);
	}
}"
`;

exports[`main should prepend a type checking to Foo#toString() 1`] = `
"
/**
 * Class Foo.
 */
class Foo {
	/**
  * Returns a string representing the object.
  *
  * @type-checked
  * @param {object} obj The object to be represented as
  *        a string.
  * @return {string} A string representing the object.
  */
	toString(obj) {
		if (Object.prototype.toString.call(obj) !== '[object Object]') {
			throw new TypeError('Argument obj must be an object.');
		}
		return obj.toString();
	}
}"
`;
